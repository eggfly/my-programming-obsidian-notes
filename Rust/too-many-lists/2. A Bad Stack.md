#2020-09 

# 2.1 Layout
这个实现不好：
``` Rust
pub enum List {
    Empty,
    Elem(i32, Box<List>),
}
```

## 2.1.1  stack 和 heap 不统一：
``` Rust
[] = Stack
() = Heap

[Elem A, ptr] -> (Elem B, ptr) -> (Empty, *junk*)
```

这会导致一些麻烦，比如如果要拆分列表，就会涉及 stack 和 heap 的挪来挪去。如果 Elem 尺寸小的话就无所谓。但是如果 Elem 尺寸很大，就会麻烦。而且这个布局也不优美。
``` Rust
layout 1:
[Elem A, ptr] -> (Elem B, ptr) -> (Elem C, ptr) -> (Empty *junk*)

split off C:
[Elem A, ptr] -> (Elem B, ptr) -> (Empty *junk*)
[Elem C, ptr] -> (Empty *junk*)
```

所以可以引入一个指针，只有指针在 stack 上，所有 node 都在 heap 上，则解决这个问题：
``` Rust
layout 2:
[ptr] -> (Elem A, ptr) -> (Elem B, ptr) -> (Elem C, *junk*)

split off C:
[ptr] -> (Elem A, ptr) -> (Elem B, *junk*)
[ptr] -> (Elem C, *junk*)

```

所以有了新的一版实现：
``` Rust
pub struct List {
	head: Box<Link>
}

enum Link {
    Empty,
    Elem(i32, Box<Link>),
}
```

## 2.1.2 `Link::Empty`里有 junk

`Link::Empty`本质上只有一个 bit 的信息。但是 `Link::Elem(i32, Box<Link>)` 却是一个 struct 的大小。所以考虑把 `Link::Elem` 再包装一下，变成这样的形式：
``` Rust
pub struct List {
	head: Box<Link>
}

enum Link {
	Empty,
	Box<Node>
}

struct Node(i32, Box<Link>)
```

恰好这时候因为 `enum Link` 里面一个是非空指针（`Box`保证的），一个是只有一个 bit 的信息（`Link::Empty`），可以通过 null pointer optimization 用 **全0指针** 来表达 。从而 `Link` 的内存布局就变成一个指针的布局了，整齐极了。

``` Rust
layout 2:
[ptr1] -> (ptr2) -> (Elem A, ptr2) -> (Elem B, ptr2) -> (Elem C, *null*)

split off C:
[ptr1] -> (ptr2) -> (Elem A, ptr2) -> (Elem B, *null*)
[ptr1] -> (ptr2) -> (Elem C, *null*)
```

## 2.1.3 简化 `Link` 和 `Node`
现在 `Link` 本身只是指针大小，所以 `List` 里就不需要再通过指针来规避 stack vs heap 问题了。
``` Rust
pub struct List {
	head: Link
}

enum Link {
	Empty,
	Box<Node>
}

struct Node(i32, Box<Link>)
```

注意 `Node` 中的 `Box` 和 `Link` 都是指针，这里用两个指针没有必要。所以可以再简化：
``` Rust
pub struct List {
	head: Link
}

enum Link {
	Empty,
	Box<Node>
}

struct Node(i32, Link)
```

``` Rust
layout 2:
[ptr] -> (Elem A, ptr) -> (Elem B, ptr) -> (Elem C, *null*)

split off C:
[ptr] -> (Elem A, ptr) -> (Elem B, *null*)
[ptr] -> (Elem C, *null*)
```

## 2.1.4 可读性
`Node` 是 tuple struct，引用成员变量会有点麻烦（`Node.0`, `Node.1`）。所以给个名字吧：
``` Rust
pub struct List {
    head: Link,
}

enum Link {
    Empty,
    More(Box<Node>),
}

struct Node {
    elem: i32,
    next: Link,
}
```

## 2.1.5 我的思考
`Node` 里面的 `Link` 实际上就是 C 版本里的 `next` 指针
``` C
struct Node {
	int elem;
	struct Node *next;
};
```
因为 Rust 里没法表示空指针，所以要用 `enum` 来表达这个意思。Rust 里面也没法直接表示指针，所以要用 `Box` 来间接达到指针的效果。

`Node` 和 C 版本的 `Node` 相同。

那么 `List` 是用来干什么的呢？不要行不行？直接用`Link`来存储链表行不行？其实我觉得**行**。用 `List` 包装 `Link` 可能只是为了类定义的存粹性。毕竟 `List` 里面是直接包含 `Link`，而不是指针，所以在 stack vs heap 的问题上没有区别。
``` Rust
type List = Link;

enum Link {
    Empty,
    More(Box<Node>),
}

struct Node {
    elem: i32,
    next: Link,
}
```


# 2.2 `List::new()`
``` Rust
impl List {
    pub fn new() -> Self {
        List { head: Link::Empty }
    }
}
```

# 2.3 略过

# 2.4 `List::push(&mut self, i32 val)`
#TODO 