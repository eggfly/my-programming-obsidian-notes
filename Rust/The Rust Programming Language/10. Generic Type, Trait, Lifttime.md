# 10.1 Generic
## basic
```
struct A<T> { a: T, b: T }

impl<T> A<T> {
    fn bar(&self) {}
}

impl A<i32> {
    fn foo(&self) {}
    fn bar(&self) {} // <--- 这个会编译错误，和 impl<T> 版本的 bar 重复定义
                     //      可见没有类似 C++ 的偏特化
}

fn main() {
    let a = A { a: 5, b: 4};
    a.foo();
    a.bar();
}
```

## monomorphization
```
fn main() {
    let a = Some(5);
    let b = Some(5.0);
}
```
会被编译器自动变成，这个叫做 monomorphization
```
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
```

# 10.2 Trait
## 一个限制
- 不可以在我的 crate 里为一个外部 struct 实现 一个外部 trait
- 这是为了保证安全，确保本crate里是按照该 struct 和 该 trait 定义的行为在运行。
- 这个限制叫做 **orphan rule(孤儿规则)**，是 coherence 的一部分。
	- 更多可参照 [[rust-orphan-rules]]

## 默认 trait 函数实现
一个限制：在overriding 的实现里，不可能调用默认实现
``` rust
Trait T {
    fn foo(&self) {             // <----|
		// <---  这是默认实现          // |
	}                                // |
}                                    // |
                                     // |
struct A {}                          // |
impl T for A {                       // |
	fn foo(&self) {                  // |
		// <--- 可以override自己的实现 // |
		// <--- 但是不可能再调用默认实现 ----
	}
}
```

## 三种Trait做参数的实现
``` rust
fn foo(a: &impl TA, b: &impl TB) {}  <--- 注意有 impl 字眼。下面两种方法没有

fn foo<T1: TA, T2: TB>(a: &T1, b: &T2) {}

fn foo<T1, T2>(a: &T1, b: &T2) where T1: TA, T2: TB {}
```

## 组合 Trait 做参数
``` rust
fn foo(a: &(impl T1 + T2)) {} <--- 注意 & 是在括号里的
fn foo<T: T1+T2>(a: &T) {}
fn foo<T>(a: &T) where T: T1+T2 {}
```
 
## 例子
 ``` rust
 fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}
```

## blanket implementation
只对T=MyTrait 的 generic 类定义函数
``` rust
struct A<T> {}

Trait MyTrait {}

impl <T: MyTrait> for A<T> {
	fn bar() {}
}
```

只对继承了MyTrait的**普通类**定义函数。用法是一样的
``` rust
Trait MyTrait {}

impl <T: MyTrait> for T { // <---  注意 for 后面只有T
	fn bar() {}
}
```
这个技巧在 std 里用的很多。比如 `impl <T: std::fmt::Display> ToString for T {}`