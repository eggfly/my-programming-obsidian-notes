# 15.1 `Box<T>`
`Box<T>` 用于在 heap 分配内存。 ---- 默认borrow虽然也有owner概念，可是其实是在 stack 上的。

`Box<T>` 其实就是一个带了 `Deref` 和 `Drop` 语法的指针。其大小就是一个指针的大小。

## basic
``` rust
fn main() {
    let b = Box::new(5);    // <--- 类似于 C 中 new int(5)
    println!("b = {}", b);  // <--- 不需要 *b
}
```

## `cons`
`cons` 是 Lisp 里的一个东西，大概就是 `(a, (b, (c, (...(z, Nil)...))))` 这样。我感觉这就是数学里 +1 的对应。

``` rust
enum List {
    Cons(i32, List),      // <--- 这个无法编译 
    Nil,
}

enum List {
    Cons(i32, Box<List>), // <---  这个可以编译
    Nil,
}
```

# 15.2 `Deref` Trait

## 例子
``` rust
impl<T> std::ops::Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &T {  // <--- 注意返回的是 reference
        &self.xxx
    }
}

let x = MyBox<i32> {...}
let y = *(x.deref());      // <--- 完整写法
let z = *y;                // <--- 简易写法，编译器会自动展开成上一行那样
```

## Deref Coercion
deref coercion 发生在这两个条件**同时**满足时：
- 是作为 reference 使用的。更具体的，是输入类型是 `&T`，期待类型却是 `&U` 时。如 `let t = T{}; let a :&U = &t;`
- 该类型实现了到目标类型引用的 `Deref` Trait。`fn deref(&self) -> &TargetType {...}`

所以 deref coercion 和上面的 `*a`  自动展开**不是**同一回事。

### 例子1
``` rust
fn hello(name: &str) { ... }

fn main() {
    let m = Box::new(String::from("Rust"));
    hello(&m); // <--- 发生了两次 deref coercion
}
```
上面这个例子中，发生了两次 deref coercion:
- `&Box<String>` -> `&String`
- `&String` -> `&str`

### 例子2
``` rust
struct A { }

impl std::ops::Deref for A {
    type Target = i32;      // <--- 可以是别的类型。。。
    fn deref(&self) -> &i32 { &3 } 
}

fn main() {
    let a = A{};
    let b : &i32 = &a;      // <--- deref coercion
    println!("{}", b);
}
```

如有需要，编译器会自动做任意多次 deref coercion

## Mutability
deref coercion 在这三种情况下发生（比 [[15. Smart Pointer#Deref Coercion]] 中说的多了两种mut的情况）
- From `&T` to `&U` when `T: Deref<Target=U>`
- From `&mut T` to `&mut U` when `T: DerefMut<Target=U>`
- From `&mut T` to `&U` when T`: Deref<Target=U>` （注意是 Deref 而不是 DerefMut ）