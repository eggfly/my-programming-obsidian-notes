#2020-08 

# 19.1 `Unsafe`
5 个 Unsafe Superpowers:
- dereference raw pointer
- 调用其他 unsafe 的函数
- 操作 static mutable variable
- 实现 `unsafe trait`
- 访问 `union` 的 field

`unsafe` 不会：
- 取消 borrow checker
- 取消 safety check。

`unsafe` 用于 coder 知道没问题，但编译器不知道的时候。

## 19.1.1 dereferencing a raw pointer
两种 raw pointer
- `* const T`
- `* mut T`

用 `as` 来从 reference 获得 raw pointer。注意这个是不需要 `unsafe` 的，因为定义一个指针本身没有什么问题。只有当需要 dereference 它的时候才是不安全的。
``` Rust
let mut a = 3;
let b : &a     as * const i32; // <--- 不在 unsafe 里
let c : &mut a as * mut i32;   // <--- 不在 unsafe 里

let d = 0x12345678usize;
let e = d as * const i32;

unsafe {
	println!("{}", *c); // <--- 注意 immutable 和 mutable 同时使用
	println!("{}", *b); // <--- 注意 immutable 和 mutable 同时使用
	println!("{}", *e); // <--- 可能会 crash
}
```

## 19.1.2 calling unsafe functions/methods
``` Rsut
unsafe fn foo() {}

unsafe {
	foo();
}
```

``` Rust
fn split(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = slice.len();

    assert!(mid <= len);                      // <--- 这个保证下面 unsafe 实际上 是 safe 的

    // (&mut slice[..mid], &mut slice[mid..]) // <--- 编译错误，因一个 slice 两个 &mut
	unsafe {                                  // <--- 需要这样
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
```

### FFI
FFI: Foreign Function Interface
``` Rust
extern "C" { fn abs(input: i32) -> i32; }         // <--- 调用别人

#[no_mangle] pub extern "C" fn call_from_c() {}   // <--- 被别人调

fn main() {
    unsafe {  // <--- 调用别人需要 unsafe
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}
```

## 19.1.3 static mutable varible
``` Rust
static mut COUNTER: u32 = 0; // <--- 无法避免 data race

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;       // <--- 修改需要 unsafe
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!("COUNTER: {}", COUNTER); // <--- 读取也需要 unsafe
    }
}
```

## 19.1.4 Implementing an Unsafe Trait
我觉得这里语焉不详
``` Rust
unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}

fn main() {}
```

## 19.1.5 Accessing Fields of a Union
我觉得这里语焉不详

# 19.2 Advanced Trait
## 19.2.1 Associated types 
``` Rust
pub trait Iterator {
    type Item;         // <--- Trait 定义中的 Associated type

    fn next(&mut self) -> Option<Self::Item>;
}

impl Iterator for Counter {
    type Item = u32;   // <--- Trait 实现中的 Associated type

    fn next(&mut self) -> Option<Self::Item> { ... }
}
```

为什么不用模版？
``` Rust

// 如下用法，一个 struct 只能选一个 type 来实现 Iterator trait
pub trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}

// 如下用法，一个 struct 可以选多个 type 来实现 Iterator trait, 如 Iterator<i32>, Iterator<f64> 等
pub trait Iterator<T> {
    fn next(&mut self) -> Option<T>;
}
```

## 19.2.2 default generic type
``` Rust
trait T<X=Self> { // <--- 注意 =Self
    fn foo(&self, b: X);
}

struct A {}

impl T for A {    // <--- 因为 default generic type，所以省掉了 T<A> 中的 <A>
    fn foo(&self, _b: A) { println!("xxxx"); }
} 
impl T<i32> for A {
    fn foo(&self, _b: i32) { println!("yyyy"); }
}

fn main() {
    let a = A {};
    a.foo(A{});
    a.foo(3);
}
```

## 19.2.3 fully qualified syntax
```Rust
struct A {}

impl A {
    fn foo(&self) { println!("xxxx::foo"); }
    fn bar()      { println!("xxxx::bar"); }
}

trait T {
    fn foo(&self);
    fn bar();
}

impl T for A {
    fn foo(&self) { println!("yyyy::foo"); } // <--- 重名了。
    fn bar()      { println!("yyyy::bar"); } // <--- 重名了。无 &self
}

fn main() {
    let a = A {};

    a.foo();       // <---
    A::foo(&a);    // <--- 和 a.foo() 一样的
    T::foo(&a);    // <---
    
    A::bar();         // <---
    // T::bar();      // <--- 编译错误
    <A as T>::bar();  // <---
}
```

## 19.2.4 supertrait
``` Rust
trait A { fn foo(&self); }

trait B : A { 
	fn bar(&self) { self.foo(); } 
}

struct D {}

impl B for D {} // <--- 编译错误，因为 D 没有实现 A
```

## 19.2.5 newtype
orphan rule 使得不大能建立“第三方struct + 第三方trait”的组合。这时候可以用 newtype。其实就是用一个新的 struct wrap 一下 第三方 struct，从而避开 orphan rule。
``` Rust
struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}
```
缺点：如果第三方 struct 有很多 method，那么 wrapper 也要都实现。一个绕开的方法是用 `Derefa`，`deref` 到第三方 struct。不过这样是不是对 第三方 struct 对原有 trait 无效？

# 19.3 Advanced Types
