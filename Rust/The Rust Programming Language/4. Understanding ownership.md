# 4.1 What is Ownership?
memory is managed through a system of ownership with a set of rules that the compiler checks at compile time. 

## Ownership Rules
- 每个value都有一个owner variable
- 任何时刻任何value的owner都只能有一个
- 一旦owner出了scope，它对应的value就会被drop -- 注意这个仅限于owner。参考[[4. Understanding ownership#Move]]一节。

## Memory and Allocation
Rust calls `drop` automatically at the closing curly bracket. ---- 就是个 RAII。

## Move
如果一段内存有两个variable指向它的话，同时这两个variable都会出scope，那么那段内存会被释放两次。这会崩溃。但如果默认是move语义的话，就没有这个问题了。

一个variable 被 move 之后就无效，且不再是owner，所以没有“对应的value被drop”的问题。

``` rust
let s1 = String::from("hello");
let s2 = s1;
foo(s1); // <--- 这会通不过编译，因为 s1 已经被 move 了。
```

In addition, there’s a design choice that’s implied by this: Rust will never automatically create “deep” copies of your data. Therefore, any automatic copying can be assumed to be inexpensive in terms of runtime performance.

## Clone Trait
略过

## Stack-Only data: Copy
具有Copy Trait的variable，被assign给别人后，它自己还是有效的。
``` rust
let s1 = 5;
let s2 = s1;
foo(s1); // <--- 这能通过编译，因为 5 是个integer，默认有 Copy 语义。
```

背后的哲学是，Rust认为能Copy的都是栈上的，做拷贝的代价很小。

scalar都是默认Copy的，由Copy组成的 Tuple 也是默认Copy的。

Copy 的成员必须也是 Copy。

Copy Trait 和 Drop Trait 不能共存。

## 函数传参的 ownership 规则
传参给函数参数的规则 <- 是一样的 -> assign variable 的规则。
都是 move 或者 copy。

``` rust
fn main() {
	let s = String::from("a");
	let x = 5;
	
	foo(s); // <--- move
	bar(x); // <--- copy
}

fn foo(x: String) {}

fn bar(x: i32) {}
```

## 函数返回值的 ownership 规则
也很上面一样， move 或者 copy。

# 4.2 References and Borrowing
references never has ownership.

We call having references as function parameters borrowing.

## Mutable References
data race:
- 多个指针同时访问同个数据
- 至少一个指针会改数据
- 没有sync保护

Note that a reference’s scope starts from where it is introduced and continues through ==**the last time that reference is used**==. 
```rust
let mut s: i32 = 5;

let r1 = &s;
let r2 = &s;
println!("{} {}", r1, r2);

// 后面没有r1和r2的使用，所以r1和r2已经out of scope了，所以可以有r3
let r3 = &mut s;
```

## Dangling References
Rust不允许dangling reference编译
```
fn foo() -> &i32 { // <--- 可能会 dangling reference，所以通不过编译
	let a: i32 = 3;
	a
}
```

## Rules of References
- 任何时候，要么一个 mutable reference，要么任意多个 immutable references
- 任何时候reference都是valid的。
